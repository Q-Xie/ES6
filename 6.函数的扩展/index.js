/*
* 1.函数参数的默认值
*   基本用法
*     ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。
* */
function log1(x, y) {
  y = y || 'world'
  console.log(x, y)
}

log1('hello')
log1('hello', 'china')
log1('hello', '')

/*
* ES6允许为函数的参数设置默认值，即直接写在参数定义后面。
* */
function log2(x, y = 'wold') {
  console.log(x,  y)
}
log2('hello')
log2('hello', 'china')
log2('hello', '')

/*
* ES6这样写，除了简洁之外，还有两个好处：1阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或者文档。
* 其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码没法用。
* 参数变量是默认声明，所以不能用let或者const再次声明，否则会报错。
* */

/*
* 使用默认参数时，函数不能有同名参数，否则也会报错。
* */

/*
* 参数默认不是传值的，而是每次都重新计算默认值表达式的值、也就是说，参数默认值是惰性求值的。
* */
let x = 99
function foo(p = x + 1) {
  console.log(p)
}
foo()


/*
* 与结构赋值默认值结合使用
*   参数默认值可以与结构赋值的默认值结合起来使用。
* */
function foo2({x1, y1 = 5}) {
  console.log(x1, y1)
}

// foo2({}) 会报错
foo2({x1: 1})
foo2({x1: 1, y1:2})
// foo2() 会报错

/*
* 通常情况下，默认参数应该放在函数的尾参数，如果非尾参数设置默认值，实际上这个参数是没法省略的。
* */

/*
* 函数的length属性
*   指定了默认值后，函数的length属性，将返回没有指定默认参数个数，也就是说，指定了默认值后，length属性将失真。
* */
console.log((function (a) {}).length)
console.log((function (a = 5) {}).length)
console.log((function (a, b, c = 5) {}).length)
console.log((function (a = 5, b, c) {}).length)

/*
* 上面代码中可以看的出来，length属性的返回值，等于函数的参数个数减去指定默认值的参数个数。如果默认参数在头部，那他的length
* 一样也是等于0
* */

/*
* 作用域
*   一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域，等到初始化结束，这个作用域就会消失。
* */

/*
* rest参数
*   ES6引入rest参数(形式为...变量名),用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组
*   该变量将多余的参数放入数组中。
* */
function add(...values) {
  let sum = 0
  for (let val of values) {
    sum += val
  }
  return sum
}

console.log(add(2, 5, 3))


/*
*
* 函数的length属性，不包括rest的参数。rest参数之后，也不可以有其他参数（即只能是最后一个参数），否则会报错。
* */

/*
* 3.严格模式
*   从ES5开始，函数内部就可以设定为严格模式。
*   ES6做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。
*   这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体，
*   这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。
* */


/*
* name属性
*   函数的name属性返回函数的函数名。
*   ES6做了一些修改，如果将匿名函数赋值给一个变量，ES5会返回空字符串，ES6会返回实际函数名
* */


/*
* 箭头函数
*   ES6允许使用箭头 (=>)定义函数
* */
let f2 = v => v
// 等同于
let f4 = function (v) {
  return v
}

/*
* 如果箭头函数不需要参数或者需要多个参数，就使用圆括号代表参数部分
* */
let f1 = () => 5
let sum1 = (num1, num2) => num1 + num2


/*
* 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return返回
* */
let sum2 = (num1, num2) => { return num1 + num2}

/*
* 由于大括号被解析为代码块，如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错
* */

let getTempItem = id => ({id: id, name: 'temp'})

let foo3 = () => {a:1}

/*
* 如果箭头函数只有一行语句，且不需要返回值，可以采用下面写法
* */
let fn = () => void doesNotReture()

/*
* 箭头函数可以与变量解构结合使用
* */
const full = ({first, last}) => first + ' ' + last
// 等同于
function full1(person) {
  return person.first + '' + person.last
}

/*
* 箭头函数可以简化回调函数
* */
console.log([1, 2, 3].map((x)=>x*x))


/*
* rest参数与箭头函数结合的例子
* */
const numbers = (...nums) => nums
console.log(numbers(1,2,3,4,5))


/*
* 使用箭头函数有几个使用注意点。
*   1.函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
*   2.不可以当做构造函数，也就是说，不可以使用new命令
*   3.不可以使用arguments对象，该对象在函数体内部存在，如果要用，可以用rest参数代替
*   4.不可以使用yield命令，因此箭头函数不能用作Generator函数。
* */

/*
* 不适合场合
*   1.定义对象方法，且该方法内部包括this，
*   2.需要动态this的时候，也不应该使用箭头函数
* */


/*
* 尾调用优化
*   尾调用是函数式编程的一个重要概念，就是指某个函数的最后一步调用另外一个函数。
* */
function ff() {
  return gg()
}
/*
* 上面代码中，函数ff的最后一步是调用函数gg，这就叫做尾调用。
* */



/*
* 尾递归
*   就是在尾部调用自身
* */












